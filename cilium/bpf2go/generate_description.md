
Following is an bpf2go generated file. This is a simple example about XDP. You can find it at [here](https://github.com/cilium/ebpf/blob/master/examples/xdp/bpf_bpfel.go).

And bpf2go generate similiar file to other type of program (Not Only XDP).

### file header
```go
// Example
// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || amd64p32 || arm || arm64 || mips64le || mips64p32le || mipsle || ppc64le || riscv64
// +build 386 amd64 amd64p32 arm arm64 mips64le mips64p32le mipsle ppc64le riscv64

package main // generate will custom this package name.

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)
```

Above is the header of the generated file. It will import the ebpf package and the generated file will be in the same package as the caller.

If you have some custom exported struct, bpf2go will generated it at there.

> By the way if your struct contains some chars, you can define as https://github.com/cilium/ebpf/discussions/648. 
>
> just using __u8 name[LEN] define in the struct.

### loadBpf / LoadBpf
``` go
// loadBpf returns the embedded CollectionSpec for bpf.
func loadBpf() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_BpfBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load bpf: %w", err)
	}

	return spec, err
}
```

func **loadBpf()** will load the embedded bpf object into the kernel. It will return a CollectionSpec.

This func is very useful if you want do something Like Pinning Map By Name, rewrite the Global varibale of the bpf object.

> https://github.com/cilium/ebpf/discussions/795 Global varibale rewrite.
> 
> [CollectionSpec](https://pkg.go.dev/github.com/cilium/ebpf#CollectionSpec) is a collection of programs and maps. It can be used to load a collection of programs and maps into the kernel.
> 

### loadBpfObjects / LoadBpfObjects
```go
// loadBpfObjects loads bpf and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*bpfObjects
//	*bpfPrograms
//	*bpfMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadBpfObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadBpf()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}
```

func **loadBpfObjects()** will load the embedded bpf object into the kernel. It will return a error to show whether the operation is successful.

And Also This func is the simple warpper of the **loadBpf()** and **CollectionSpec.LoadAndAssign()**.

You can see this function used in most of official examples.

### bpfSpecs / BpfSpecs
``` go
// bpfSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfSpecs struct {
	bpfProgramSpecs
	bpfMapSpecs
}

// bpfSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfProgramSpecs struct {
	XdpProgFunc *ebpf.ProgramSpec `ebpf:"xdp_prog_func"`
}

// bpfMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfMapSpecs struct {
	XdpStatsMap *ebpf.MapSpec `ebpf:"xdp_stats_map"`
}
```

This three structs are designed for maintian the Specs (I think it's kind of configure of Map or Program) that used to generate the ebpf.Program ebpf.Map Object [They are wrapped following] when they are loaded into the kernel.

> https://pkg.go.dev/github.com/cilium/ebpf#MapSpec ebpf.MapSpec Documentation
>
> https://pkg.go.dev/github.com/cilium/ebpf#ProgramSpec ebpf.ProgramSpec Documentation
>
> They contains exported fields that can be used to configure the map or program. The fields are documented in the respective documentation pages.

### bpfObjects / BpfObjects
```go
// bpfObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfObjects struct {
	bpfPrograms
	bpfMaps
}

func (o *bpfObjects) Close() error {
	return _BpfClose(
		&o.bpfPrograms,
		&o.bpfMaps,
	)
}
```

bpfObject is some kind of runtime instance. It contains Program and Map when they are loaded in kernel. 

There is wrapper of the ebpf.Program and ebpf.Map.

You can update Map key Value and other operation about Map. 

> https://pkg.go.dev/github.com/cilium/ebpf#Map ebpf.Map Documentation
>
> https://pkg.go.dev/github.com/cilium/ebpf#Program ebpf.Program Documentation
>
> They contains unexported fields that only be used in ebpf package. The fields are documented in the respective documentation pages with examples.
> 
> At most time, we used them with the help of the method defined in [link](https://pkg.go.dev/github.com/cilium/ebpf@v0.10.0/link#section-documentation) package.

```go
// bpfMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfMaps struct {
	XdpStatsMap *ebpf.Map `ebpf:"xdp_stats_map"`
}

func (m *bpfMaps) Close() error {
	return _BpfClose(
		m.XdpStatsMap,
	)
}

// bpfPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfPrograms struct {
	XdpProgFunc *ebpf.Program `ebpf:"xdp_prog_func"`
}

func (p *bpfPrograms) Close() error {
	return _BpfClose(
		p.XdpProgFunc,
	)
}
```

### file tail

```go

func _BpfClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed bpf_bpfel.o
var _BpfBytes []byte

```

Congratz. This is the end of file.

_BpfBytes is the embedded bpf object file. 

When build your complete program, the bpf object file will be embedded into the binary file as Bytes Code. cilium/ebpf will explain it as ebpf objects and load them to kernel.
